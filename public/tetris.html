<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <!-- From tutorial: https://www.youtube.com/watch?v=H2aW5V46khA -->
    <canvas id="textris" width="240" height="400"></canvas>

    <script>
      const canvas = document.getElementById('textris');
      const context = canvas.getContext('2d');

      context.scale(20,20);

      const matrix = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 1, 0]
      ];

      // collide
      function collide(arena, player) {
        const [m, o] = [player.matrix, player.pos];

        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena [y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }

      // game board
      function create_matrix(w, h) {
        const matrix = [];

        while (h--) {
          matrix.push(new Array(w).fill(0));
        }
        return matrix;
      }


      function draw_matrix(matrix, offset) {
        // magic of drawing a 2-dimensional array
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                context.fillStyle = 'red';
                context.fillRect(x + offset.x, y + offset.y, 1, 1);
              }
            });
        });
      }

      function player_drop() {
        player.pos.y++;

        if (collide(arena, player)) {
          player.pos.y--;       //move back up one
          merge(arena, player); //merge player piece to arena
          player.pos.y = 0;     //reset player back to top
        }
        drop_counter = 0; // prevents drops from stacking.
      }

      function player_move(dir) {
        player.pos.x += dir;
        if (collide(arena, player)) {
          player.pos.x -= dir;
        }
      }

      // draw function to be updated
      function draw() {
        // clears
        context.fillStyle = '#000';
        context.fillRect(0,0, canvas.width, canvas.height);

        draw_matrix(arena, {x:0, y:0});
        draw_matrix(player.matrix, player.pos);
      }

      // copies player matrix into arena matrix
      function merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              arena [y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }

      // drop related variables
      let drop_counter = 0;
      let drop_interval = 1000;
      let last_time = 0;

      // update to be looped
      function update(time = 0) {

        const delta_time = time - last_time;
        last_time = time;

        drop_counter += delta_time;

        if (drop_counter > drop_interval) {
          player_drop();
        }

        draw();
        requestAnimationFrame(update);
      }

      // create world
      const arena = create_matrix(12, 20);
      console.log(arena);
      console.table(arena);

      // wrap pos and matrix reference into player object
      const player = {
        pos: {x: 5, y: 5},
        matrix: matrix
      };


      // --- events ---
      document.addEventListener('keydown', ev => {

        if (ev.keyCode === 37) {
          player_move(-1);
        }
        else if (ev.keyCode === 39) {
          player_move(1);
        }
        if (ev.keyCode === 40) {
          player_drop();
        }

      });

      window.addEventListener('load', (ev) => {
        update();
      });


    </script>

  </body>
</html>
